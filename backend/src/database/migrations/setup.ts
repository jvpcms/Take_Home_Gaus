import { getDbConnection } from "../databaseConnection.ts";
import { customLoggerInstance } from "../../utils/customLogger.ts";
import { readdir, readFile } from "fs/promises";
import { fileURLToPath } from "url";
import { URL } from "url";
import path from "path";
import fs from "fs/promises";

const dbConnection = getDbConnection();

// Check if the migrations table exists
// If not, create it
// Retrieve the migrations files
// Run the migrations that are still waiting to be run
// Add the runned migration in the table

type Migration = {
  code: string;
  version: number;
  name: string;
};

/**
 * Get all migrations from sql files
 *
 * @returns List of migrations
 */
async function getMigrations(): Promise<Migration[]> {
  const dir = await readdir(fileURLToPath(new URL("./", import.meta.url)));
  const result: Migration[] = [];
  for await (const file of dir) {
    const ext = file.split(".").pop();
    if (!ext || ext !== "sql") {
      continue;
    }
    const version = parseInt(file.split("-")[0]);
    const name = file.replace(/^\d+/, "").slice(1, -ext.length).trim();
    const code = await readFile(
      fileURLToPath(new URL(`./${file}`, import.meta.url)),
      {
        flag: "r",
        encoding: "utf8",
      }
    );
    result.push({ version, code, name });
  }

  return result.sort((a, b) => {
    return a.version - b.version;
  });
}

/**
 * Run all not runned migrations
 *
 */
export async function migrate() {
  await dbConnection.query(
    "CREATE TABLE IF NOT EXISTS migrations (version INT PRIMARY KEY, name TEXT);"
  );

  const ranMigrations = (
    await dbConnection.query("SELECT * FROM migrations;")
      .then((result) => result.rows.map((row) => row.version))
  );

  const allMigrations = await getMigrations();

  for (const migration of allMigrations) {
    if (ranMigrations.includes(migration.version)) {
      customLoggerInstance.info(`Migration ${migration.version} has already been run.`);
      continue;
    }

    customLoggerInstance.info(`Running migration ${migration.version}: ${migration.name}`);
    await dbConnection.query(migration.code);
    await dbConnection.query("INSERT INTO migrations (version, name) VALUES ($1, $2);", [
      migration.version,
      migration.name,
    ]);
  }
}

/**
 * Get the type conversion map to convert postgre types to TypeScript types
 * @returns Type conversion map
 */
function getTypesMap(): Map<string, string> {
  const typesMap = new Map<string, string>();
  typesMap.set("integer", "number");
  typesMap.set("bigint", "string"); // Big integers are typically represented as strings in JavaScript
  typesMap.set("smallint", "number");
  typesMap.set("serial", "number");
  typesMap.set("bigserial", "string"); // Big serials are typically represented as strings
  typesMap.set("real", "number");
  typesMap.set("double precision", "number");
  typesMap.set("numeric", "string"); // Numeric values are often represented as strings to preserve precision
  typesMap.set("boolean", "boolean");
  typesMap.set("text", "string");
  typesMap.set("varchar", "string");
  typesMap.set("character varying", "string");
  typesMap.set("char", "string");
  typesMap.set("uuid", "string");
  typesMap.set("json", "any");
  typesMap.set("jsonb", "any");
  typesMap.set("date", "string"); // Dates are typically represented as strings
  typesMap.set("timestamp", "string");
  typesMap.set("timestamptz", "string"); // Timestamps with time zones
  typesMap.set("time", "string");
  typesMap.set("timetz", "string"); // Time with time zones
  typesMap.set("bytea", "Uint8Array"); // Binary data
  typesMap.set("array", "any[]"); // Arrays are represented as `any[]` by default
  typesMap.set("null", "null"); // Null values

  return typesMap;
}

/**
 * Generate types for the deatbase entities
 *
 */
export async function generateTypes() {

  const typesPath = fileURLToPath(new URL('../types', import.meta.url));

  // make sure the types directory exists
  try {
    await fs.stat(typesPath);
  } catch (e: any) {
    if (e.code !== 'ENOENT') throw e;
    await fs.mkdir(typesPath);
  }

  // make sure the types directory is empty
  const types = await fs.readdir(typesPath);
  for (const type of types) {
    await fs.rm(path.join(typesPath, type));
  }


  const typesMap = getTypesMap();

  const dateStr = new Date().toISOString().replace(/T/, " ").replace(
    /\..+/,
    "",
  );
  const warning = `// This file is generated by database/migrations/setup.ts. Do not modify it manually.\n// Last updated ${dateStr}\n\n`;

  const tableNames = await dbConnection.query(
    `SELECT table_name
     FROM information_schema.tables
     WHERE table_schema = 'public'
       AND table_type = 'BASE TABLE';`
  ).then((result) => result.rows.map((row) => row.table_name));

  let databaseSchemaImports = warning;
  let databaseSchemaType = `\nexport type DatabaseSchema = {\n`;

  // generate types
  for (const tableName of tableNames) {

    if (tableName === 'migrations') {
      continue;
    }

    databaseSchemaImports += `import { ${tableName} } from "./${tableName}.ts";\n`
    databaseSchemaType += `    ${tableName}: ${tableName}\n`;

    const columns = await dbConnection.query(
      `SELECT column_name, data_type, is_nullable
       FROM information_schema.columns
       WHERE table_name = $1
       AND table_schema = 'public';`,
      [tableName]
    ).then((result) => result.rows);

    let typeFileContent = warning;
    typeFileContent += `export interface ${tableName} {\n`;

    for (const column of columns) {
      const convertedType = typesMap.get(column.data_type);
      const isNullable = column.is_nullable === 'YES';

      const typeString = convertedType ? (convertedType + (isNullable ? " | null" : "")) : "any";

      typeFileContent += `    ${column.column_name}: ${typeString};\n`;
    }

    typeFileContent += `}\n`;
    await fs.writeFile(`${typesPath}/${tableName}.ts`, typeFileContent, { encoding: 'utf8' });
    customLoggerInstance.info(`Generated type for table ${tableName}`);
  }

  databaseSchemaType += `};\n`;
  const databaseSchemaFileContent = databaseSchemaImports + databaseSchemaType;
  await fs.writeFile(`${typesPath}/databaseSchema.ts`, databaseSchemaFileContent, { encoding: 'utf8' });
  customLoggerInstance.info(`Generated databaseSchema.ts`);
}